esphome:
  name: cheese-controleur
  friendly_name: cheese_controleur
  on_boot:
    priority: 200
    then:
      - lambda: |-
          // Inhibe toute commutation des relais pendant 10s après boot
          id(inhibit_until_ms) = millis() + 10000;
      - binary_sensor.template.publish:
          id: lcd_backlight_state
          state: ON

esp32:
  board: lolin_s2_mini
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "dGGqosLqZi3WxY8iEa6ojL+ZyvUq9MW4nUgOfO/DiH8="

time:
  - platform: homeassistant
    id: esptime

ota:
  - platform: esphome
    password: "7a19002914a4586874c5f57efb4544d6"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Cheese-Controleur"
    password: "biPJgp1KeqBd"

captive_portal:

i2c:
  sda: GPIO2
  scl: GPIO1

one_wire:
  - platform: gpio
    pin: GPIO8

font:
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "gfonts://Roboto"
    id: font_medium
    size: 14
  - file: "gfonts://Roboto"
    id: font_tiny
    size: 10

globals:
  - id: inhibit_until_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: r1_last_change_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: r1_on_start_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: r2_last_change_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: r2_on_start_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  # ---- Probe slope / drop tracking ----
  - id: prb_last_sample_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: prb_last_value
    type: float
    restore_value: no
    initial_value: "NAN"

  - id: prb_drop_c_per_10m
    type: float
    restore_value: no
    initial_value: "0.0"

  # ---- Air safety latch (hysteresis) ----
  - id: air_safety_latched
    type: bool
    restore_value: no
    initial_value: "false"

number:
  # ---- TEMP (Probe) ----
  - platform: template
    name: "Temp Setpoint (Probe)"
    id: setpoint
    optimistic: true
    restore_value: true
    min_value: 4
    max_value: 20
    step: 0.1
    initial_value: 11.5

  - platform: template
    name: "Temp Band (Probe)"
    id: alarm_band
    optimistic: true
    restore_value: true
    min_value: 0.2
    max_value: 3.0
    step: 0.1
    initial_value: 0.5

  # Seuil "FAR"
  - platform: template
    name: "Temp FAR delta (°C)"
    id: temp_far_delta
    optimistic: true
    restore_value: true
    min_value: 0.5
    max_value: 8.0
    step: 0.1
    initial_value: 2.8
    unit_of_measurement: "°C"

  # Seuil "MID" (entre FAR et NEAR)
  - platform: template
    name: "Temp MID delta (°C)"
    id: temp_mid_delta
    optimistic: true
    restore_value: true
    min_value: 0.3
    max_value: 5.0
    step: 0.1
    initial_value: 1.0
    unit_of_measurement: "°C"

  # Coupe sécurité sur l’air: air < (sp - air_safety_delta) => latch ON (OFF immédiat)
  - platform: template
    name: "Air safety delta (°C)"
    id: air_safety_delta
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 15
    step: 0.1
    initial_value: 7.5
    unit_of_measurement: "°C"

  # Hystérésis air (évite oscillation autour de air_cut)
  - platform: template
    name: "Air safety hyst (°C)"
    id: air_safety_hyst
    optimistic: true
    restore_value: true
    min_value: 0.0
    max_value: 3.0
    step: 0.1
    initial_value: 0.6
    unit_of_measurement: "°C"

  # Timings FAR (loin) - recommandés
  - platform: template
    name: "R1 FAR Max ON (sec)"
    id: r1_far_max_on_sec
    optimistic: true
    restore_value: true
    min_value: 10
    max_value: 600
    step: 10
    initial_value: 360
    unit_of_measurement: "s"

  - platform: template
    name: "R1 FAR Min OFF (sec)"
    id: r1_far_min_off_sec
    optimistic: true
    restore_value: true
    min_value: 60
    max_value: 7200
    step: 30
    initial_value: 300
    unit_of_measurement: "s"

  # Timings NEAR (proche) - recommandés
  - platform: template
    name: "R1 NEAR Max ON (sec)"
    id: r1_near_max_on_sec
    optimistic: true
    restore_value: true
    min_value: 10
    max_value: 300
    step: 5
    initial_value: 90
    unit_of_measurement: "s"

  - platform: template
    name: "R1 NEAR Min OFF (sec)"
    id: r1_near_min_off_sec
    optimistic: true
    restore_value: true
    min_value: 120
    max_value: 7200
    step: 60
    initial_value: 900
    unit_of_measurement: "s"

  # Bonus OFF dynamique proche consigne
  - platform: template
    name: "R1 OFF Bonus (sec) near"
    id: r1_off_bonus_sec
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 7200
    step: 60
    initial_value: 1200
    unit_of_measurement: "s"

  # Pente: si la probe descend vite, on allonge l'attente
  - platform: template
    name: "Probe Fast Drop (°C / 10min)"
    id: probe_fast_drop_c_per_10m
    optimistic: true
    restore_value: true
    min_value: 0.1
    max_value: 5.0
    step: 0.1
    initial_value: 1.0
    unit_of_measurement: "°C"

  - platform: template
    name: "R1 OFF Bonus (sec) if fast drop"
    id: r1_off_bonus_fastdrop_sec
    optimistic: true
    restore_value: true
    min_value: 0
    max_value: 7200
    step: 60
    initial_value: 900
    unit_of_measurement: "s"

  # ---- HUMIDITY ----
  - platform: template
    name: "Humidity Setpoint"
    id: humidity_setpoint
    optimistic: true
    restore_value: true
    min_value: 40
    max_value: 95
    step: 1
    initial_value: 85
    unit_of_measurement: "%"

  - platform: template
    name: "Humidity Band"
    id: humidity_band
    optimistic: true
    restore_value: true
    min_value: 1
    max_value: 15
    step: 1
    initial_value: 3
    unit_of_measurement: "%"

  - platform: template
    name: "R2 Max ON (sec)"
    id: r2_max_on_sec
    optimistic: true
    restore_value: true
    min_value: 30
    max_value: 600
    step: 10
    initial_value: 300
    unit_of_measurement: "s"

  - platform: template
    name: "R2 Min OFF (sec)"
    id: r2_min_off_sec
    optimistic: true
    restore_value: true
    min_value: 60
    max_value: 7200
    step: 60
    initial_value: 600
    unit_of_measurement: "s"

  # ---- LCD backlight timeout ----
  - platform: template
    name: "Screen Timeout (minutes)"
    id: screen_timeout_min
    optimistic: true
    restore_value: true
    min_value: 1
    max_value: 30
    step: 1
    initial_value: 5
    on_value:
      then:
        - binary_sensor.template.publish:
            id: lcd_backlight_state
            state: ON

  # ---- Calibration CT ----
  - platform: template
    name: "CT Gain"
    id: ct_gain
    optimistic: true
    restore_value: true
    min_value: 0.1
    max_value: 200.0
    step: 0.1
    initial_value: 1.0
    unit_of_measurement: "x"

  - platform: template
    name: "CT Offset"
    id: ct_offset
    optimistic: true
    restore_value: true
    min_value: -5.0
    max_value: 5.0
    step: 0.01
    initial_value: 0.0
    unit_of_measurement: "A"

output:
  - platform: gpio
    id: relay1_out
    pin: GPIO34
    inverted: true

  - platform: gpio
    id: relay2_out
    pin: GPIO21
    inverted: true

  - platform: ledc
    pin: GPIO40
    id: out_red
    frequency: 1000 Hz
    inverted: true
  - platform: ledc
    pin: GPIO38
    id: out_green
    frequency: 1000 Hz
    inverted: true
  - platform: ledc
    pin: GPIO36
    id: out_blue
    frequency: 1000 Hz
    inverted: true

switch:
  - platform: output
    name: "Relay 1 (Freezer)"
    id: relay_freezer
    output: relay1_out
    restore_mode: ALWAYS_OFF

  - platform: output
    name: "Relay 2 (Humidifier)"
    id: relay_2
    output: relay2_out
    restore_mode: ALWAYS_OFF

light:
  - platform: rgb
    name: "Cheese Status LED"
    id: status_led
    red: out_red
    green: out_green
    blue: out_blue
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s
      - strobe:
          name: "Strobe"
          colors:
            - state: true
              brightness: 100%
              duration: 300ms
            - state: false
              duration: 300ms
      - random:
          name: "Rainbow"
          transition_length: 800ms
          update_interval: 800ms

display:
  - platform: lcd_pcf8574
    id: lcd2004
    dimensions: 20x4
    address: 0x27
    update_interval: 1s
    lambda: |-
      const uint32_t now = millis();

      const float airT = id(cheese_room_temp).state;
      const float airH = id(cheese_room_hum).state;

      const float prbT = id(cheese_probe_temp).state;
      const float sp   = id(setpoint).state;
      const float band = id(alarm_band).state;

      const bool prb_valid = !isnan(prbT);
      const bool air_valid = !isnan(airT);

      const bool too_hot  = prb_valid && (prbT > (sp + band));
      const bool too_cold = prb_valid && (prbT < (sp - band));

      // Air safety latch info
      const float air_cut_on  = sp - id(air_safety_delta).state;
      const float air_cut_off = air_cut_on + id(air_safety_hyst).state;

      // Zones
      const float delta = prb_valid ? (prbT - sp) : 0.0f;
      const float far_delta = id(temp_far_delta).state;
      const float mid_delta = id(temp_mid_delta).state;

      const char* zone = "NEAR";
      if (prb_valid) {
        if (delta > far_delta) zone = "FAR";
        else if (delta > mid_delta) zone = "MID";
        else zone = "NEAR";
      }

      const bool r1_on = id(relay_freezer).state;
      const bool r2_on = id(relay_2).state;

      // Estimation wait R1 (recalcule la même logique min_off dynamique, pour l'affichage)
      uint32_t min_off_ms_base = (uint32_t)(id(r1_near_min_off_sec).state * 1000.0f);
      if (prb_valid) {
        if (delta > far_delta) {
          min_off_ms_base = (uint32_t)(id(r1_far_min_off_sec).state * 1000.0f);
        } else if (delta > mid_delta) {
          // interpolation MID
          const float t = (delta - mid_delta) / (far_delta - mid_delta + 0.0001f);
          const float far_off = id(r1_far_min_off_sec).state;
          const float near_off= id(r1_near_min_off_sec).state;
          const float off_s = near_off + t * (far_off - near_off);
          min_off_ms_base = (uint32_t)(off_s * 1000.0f);
        } else {
          min_off_ms_base = (uint32_t)(id(r1_near_min_off_sec).state * 1000.0f);
        }
      }

      uint32_t min_off_ms = min_off_ms_base;
      if (too_hot && prb_valid) {
        float f = 0.0f;
        if (delta <= mid_delta) f = 1.0f;
        else if (delta >= far_delta) f = 0.0f;
        else f = 1.0f - ((delta - mid_delta) / (far_delta - mid_delta + 0.0001f));

        min_off_ms += (uint32_t)(id(r1_off_bonus_sec).state * 1000.0f * f);

        const float fast_th = id(probe_fast_drop_c_per_10m).state;
        if (id(prb_drop_c_per_10m) > fast_th) {
          min_off_ms += (uint32_t)(id(r1_off_bonus_fastdrop_sec).state * 1000.0f);
        }
      }

      uint32_t r1_wait_left = 0;
      if (!r1_on && id(r1_last_change_ms) != 0) {
        uint32_t elapsed = now - id(r1_last_change_ms);
        if (elapsed < min_off_ms) r1_wait_left = (min_off_ms - elapsed) / 1000;
      }

      const char* r1_mode = "IDLE";
      if (id(air_safety_latched)) r1_mode = "AIR!";
      else if (r1_on) r1_mode = zone;
      else if (too_hot && r1_wait_left > 0) r1_mode = "WAIT";
      else if (too_hot) r1_mode = "NEED";

      // HUM logic (simple)
      const float hsp = id(humidity_setpoint).state;
      const float hbd = id(humidity_band).state;
      const bool hum_valid = !isnan(airH);
      const bool too_dry = hum_valid && (airH < (hsp - hbd));

      uint32_t r2_wait_left = 0;
      const uint32_t r2_min_off_ms = (uint32_t)(id(r2_min_off_sec).state * 1000.0f);
      if (!r2_on && id(r2_last_change_ms) != 0) {
        uint32_t elapsed = now - id(r2_last_change_ms);
        if (elapsed < r2_min_off_ms) r2_wait_left = (r2_min_off_ms - elapsed) / 1000;
      }

      const char* r2_mode = "IDLE";
      if (r2_on) r2_mode = "HUM";
      else if (too_dry && r2_wait_left > 0) r2_mode = "WAIT";
      else if (too_dry) r2_mode = "NEED";

      // Ligne 0
      it.printf(0, 0, "Air:%4.1fC H:%3.0f%%", airT, airH);

      // Ligne 1 (ajout delta + drop)
      it.printf(0, 1, "Prb:%4.1f Sp:%4.1f", prbT, sp);

      // Ligne 2
      it.printf(0, 2, "R1:%c %-4s R2:%c %-4s",
        r1_on ? '1' : '0', r1_mode,
        r2_on ? '1' : '0', r2_mode);

      // Ligne 3 : waits + drop + heure (drop en °C/10m)
      it.printf(0, 3, "W1:%3us d:%3.1f %s",
        r1_wait_left,
        id(prb_drop_c_per_10m),
        id(esptime).now().strftime("%H:%M").c_str());

sensor:
  - platform: dht
    pin: GPIO6
    model: DHT22
    temperature:
      name: "Cheese Air Temperature"
      id: cheese_room_temp
      filters:
        - lambda: if (isnan(x)) return {}; else return x;
    humidity:
      name: "Cheese Air Humidity"
      id: cheese_room_hum
      filters:
        - lambda: if (isnan(x)) return {}; else return x;
    update_interval: 60s

  - platform: dallas_temp
    name: "Cheese Probe Temperature"
    id: cheese_probe_temp
    update_interval: 30s
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1

  # CT clamp
  - platform: adc
    pin: GPIO10
    id: adc_ct
    attenuation: 12db
    update_interval: 1s

  - platform: ct_clamp
    sensor: adc_ct
    name: "Freezer Current Raw"
    id: freezer_current_raw
    sample_duration: 200ms
    update_interval: 1s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

  - platform: template
    name: "Freezer Current"
    id: freezer_current
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    update_interval: 1s
    lambda: |-
      float i = id(freezer_current_raw).state;
      if (isnan(i)) return NAN;
      return (i * id(ct_gain).state) + id(ct_offset).state;

  - platform: template
    name: "Freezer Power (Estimated)"
    id: freezer_power_w
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 1s
    lambda: |-
      const float V = 120.0;
      float p = id(freezer_current).state * V;
      if (isnan(p) || p < 500.0) return 0.0;  // coupe sous 500W (à ajuster si besoin)
      return p;

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLDOWN
    name: "Cheese PIR"
    device_class: motion
    id: pir_motion
    filters:
      - delayed_on: 50ms
    on_press:
      then:
        - binary_sensor.template.publish:
            id: lcd_backlight_state
            state: ON

  # Backlight “virtuel” avec delayed_off dynamique
  - platform: template
    id: lcd_backlight_state
    filters:
      - delayed_off: !lambda |-
          return (uint32_t)(id(screen_timeout_min).state * 60.0f);
    on_press:
      then:
        - lambda: |-
            id(lcd2004).backlight();
    on_release:
      then:
        - lambda: |-
            id(lcd2004).no_backlight();

  # Courant significatif quand le freezer tourne (~500W@120V => ~4.2A)
  - platform: template
    name: "Freezer Current Active"
    id: freezer_current_active
    lambda: |-
      const float i = id(freezer_current).state;
      if (isnan(i)) return false;
      return i > 4.2;
    filters:
      - delayed_on: 2s
      - delayed_off: 10s

  # Fault si relais ON mais pas de courant (après délai)
  - platform: template
    name: "Freezer Fault (Relay ON no current)"
    id: freezer_fault_no_current
    lambda: |-
      return id(relay_freezer).state && !id(freezer_current_active).state;
    filters:
      - delayed_on: 60s
      - delayed_off: 5s

interval:
  # -------- RELAY 1 (TEMP) : FAR/MID/NEAR + OFF dynamique + pente + safety AIR latch --------
  - interval: 5s
    then:
      - lambda: |-
          const uint32_t now = millis();
          if (now < id(inhibit_until_ms)) return;

          const float prbT = id(cheese_probe_temp).state;
          if (isnan(prbT)) return;

          const float sp   = id(setpoint).state;
          const float band = id(alarm_band).state;

          // --- Pente (°C / 10 min), mise à jour ~toutes les 60s ---
          if (id(prb_last_sample_ms) == 0 || isnan(id(prb_last_value))) {
            id(prb_last_sample_ms) = now;
            id(prb_last_value) = prbT;
            id(prb_drop_c_per_10m) = 0.0f;
          } else {
            const uint32_t dt_ms = now - id(prb_last_sample_ms);
            if (dt_ms >= 60000) { // 60s
              const float dT = id(prb_last_value) - prbT; // positif si ça descend
              const float minutes = dt_ms / 60000.0f;
              const float drop_per_10m = (minutes > 0) ? (dT * (10.0f / minutes)) : 0.0f;
              id(prb_drop_c_per_10m) = drop_per_10m;
              id(prb_last_sample_ms) = now;
              id(prb_last_value) = prbT;
            }
          }

          // --- Demandes sur PROBE ---
          const bool too_hot  = prbT > (sp + band);
          const bool too_cold = prbT < (sp - band);

          // --- Safety cut AIR + hystérésis + latch ---
          const float airT = id(cheese_room_temp).state;
          const bool air_valid = !isnan(airT);

          const float air_cut_on  = sp - id(air_safety_delta).state;
          const float air_cut_off = air_cut_on + id(air_safety_hyst).state;

          if (air_valid) {
            if (!id(air_safety_latched) && (airT < air_cut_on)) id(air_safety_latched) = true;
            else if (id(air_safety_latched) && (airT > air_cut_off)) id(air_safety_latched) = false;
          }

          const bool r1_on = id(relay_freezer).state;

          // init timestamps
          if (id(r1_last_change_ms) == 0) id(r1_last_change_ms) = now;
          if (r1_on && id(r1_on_start_ms) == 0) id(r1_on_start_ms) = now;

          // OFF immédiat si trop froid probe OU air latch
          if ((too_cold || id(air_safety_latched)) && r1_on) {
            id(relay_freezer).turn_off();
            id(r1_last_change_ms) = now;
            id(r1_on_start_ms) = 0;
            return;
          }

          // --- Zones FAR / MID / NEAR ---
          const float far_delta = id(temp_far_delta).state;
          const float mid_delta = id(temp_mid_delta).state;

          const float delta = prbT - sp;

          enum Zone {NEAR, MID, FAR};
          Zone zone = NEAR;
          if (delta > far_delta) zone = FAR;
          else if (delta > mid_delta) zone = MID;
          else zone = NEAR;

          uint32_t max_on_ms;
          uint32_t min_off_ms_base;

          if (zone == FAR) {
            max_on_ms       = (uint32_t)(id(r1_far_max_on_sec).state  * 1000.0f);
            min_off_ms_base = (uint32_t)(id(r1_far_min_off_sec).state * 1000.0f);
          } else if (zone == MID) {
            const float t = (delta - mid_delta) / (far_delta - mid_delta + 0.0001f);
            const float far_on  = id(r1_far_max_on_sec).state;
            const float near_on = id(r1_near_max_on_sec).state;
            const float far_off = id(r1_far_min_off_sec).state;
            const float near_off= id(r1_near_min_off_sec).state;

            const float on_s  = near_on  + t * (far_on  - near_on);
            const float off_s = near_off + t * (far_off - near_off);

            max_on_ms       = (uint32_t)(on_s  * 1000.0f);
            min_off_ms_base = (uint32_t)(off_s * 1000.0f);
          } else {
            max_on_ms       = (uint32_t)(id(r1_near_max_on_sec).state  * 1000.0f);
            min_off_ms_base = (uint32_t)(id(r1_near_min_off_sec).state * 1000.0f);
          }

          // --- Min OFF dynamique : plus on est proche, plus on attend ---
          uint32_t min_off_ms = min_off_ms_base;

          if (too_hot) {
            float f = 0.0f;
            if (delta <= mid_delta) f = 1.0f;
            else if (delta >= far_delta) f = 0.0f;
            else f = 1.0f - ((delta - mid_delta) / (far_delta - mid_delta + 0.0001f));

            min_off_ms += (uint32_t)(id(r1_off_bonus_sec).state * 1000.0f * f);

            const float fast_th = id(probe_fast_drop_c_per_10m).state;
            if (id(prb_drop_c_per_10m) > fast_th) {
              min_off_ms += (uint32_t)(id(r1_off_bonus_fastdrop_sec).state * 1000.0f);
            }
          }

          // --- Si ON : coupe au bout de max_on_ms ---
          if (r1_on) {
            if ((now - id(r1_on_start_ms)) >= max_on_ms) {
              id(relay_freezer).turn_off();
              id(r1_last_change_ms) = now;
              id(r1_on_start_ms) = 0;
            }
            return;
          }

          // --- Si OFF : attend min_off avant de rallumer ---
          const bool can_turn_on = (now - id(r1_last_change_ms)) >= min_off_ms;

          if (too_hot && can_turn_on && !id(air_safety_latched)) {
            id(relay_freezer).turn_on();
            id(r1_last_change_ms) = now;
            id(r1_on_start_ms) = now;
          }

  # -------- RELAY 2 (HUM) : max_on + min_off --------
  - interval: 5s
    then:
      - lambda: |-
          const uint32_t now = millis();
          if (now < id(inhibit_until_ms)) return;

          const float h = id(cheese_room_hum).state;
          if (isnan(h)) return;

          const float sp   = id(humidity_setpoint).state;
          const float band = id(humidity_band).state;

          const bool too_dry = h < (sp - band);
          const bool too_wet = h > (sp + band);

          const uint32_t max_on_ms  = (uint32_t)(id(r2_max_on_sec).state  * 1000.0f);
          const uint32_t min_off_ms = (uint32_t)(id(r2_min_off_sec).state * 1000.0f);

          if (id(r2_last_change_ms) == 0) id(r2_last_change_ms) = now;

          const bool r2_on = id(relay_2).state;

          if (r2_on && id(r2_on_start_ms) == 0) id(r2_on_start_ms) = now;

          if (too_wet && r2_on) {
            id(relay_2).turn_off();
            id(r2_last_change_ms) = now;
            id(r2_on_start_ms) = 0;
            return;
          }

          if (r2_on) {
            if ((now - id(r2_on_start_ms)) >= max_on_ms) {
              id(relay_2).turn_off();
              id(r2_last_change_ms) = now;
              id(r2_on_start_ms) = 0;
            }
            return;
          }

          const bool can_turn_on = (now - id(r2_last_change_ms)) >= min_off_ms;

          if (too_dry && can_turn_on) {
            id(relay_2).turn_on();
            id(r2_last_change_ms) = now;
            id(r2_on_start_ms) = now;
          }

  # -------- LED status --------
  - interval: 5s
    then:
      - lambda: |-
          const float prbT = id(cheese_probe_temp).state;
          const float sp   = id(setpoint).state;
          const float band = id(alarm_band).state;

          const bool prb_valid = !isnan(prbT);
          const bool too_hot  = prb_valid && (prbT > (sp + band));
          const bool too_cold = prb_valid && (prbT < (sp - band));

          if (id(freezer_fault_no_current).state) {
            auto c = id(status_led).turn_on();
            c.set_rgb(1.0, 0.0, 1.0);
            c.set_brightness(1.0);
            c.set_effect("Strobe");
            c.perform();
            return;
          }

          if (too_hot) {
            auto c = id(status_led).turn_on();
            c.set_rgb(1.0, 0.0, 0.0);
            c.set_brightness(1.0);
            c.set_effect("Strobe");
            c.perform();
            return;
          }

          if (too_cold) {
            auto c = id(status_led).turn_on();
            c.set_rgb(0.0, 0.0, 1.0);
            c.set_brightness(1.0);
            c.set_effect("Strobe");
            c.perform();
            return;
          }

          const bool cooling = id(relay_freezer).state;
          const bool humid   = id(relay_2).state;

          if (cooling && humid) {
            auto c = id(status_led).turn_on();
            c.set_rgb(1.0, 0.0, 1.0);
            c.set_brightness(0.6);
            c.set_effect("Pulse");
            c.perform();
            return;
          }

          if (cooling) {
            auto c = id(status_led).turn_on();
            c.set_rgb(0.0, 1.0, 1.0);
            c.set_brightness(0.6);
            c.set_effect("Pulse");
            c.perform();
            return;
          }

          if (humid) {
            auto c = id(status_led).turn_on();
            c.set_rgb(0.0, 1.0, 0.0);
            c.set_brightness(0.6);
            c.set_effect("Pulse");
            c.perform();
            return;
          }

          auto c = id(status_led).turn_on();
          c.set_brightness(0.4);
          c.set_effect("Rainbow");
          c.perform();

text_sensor:
  - platform: template
    name: "Cheese Debug Line"
    id: cheese_debug_line
    update_interval: 10s
    lambda: |-
      const float airT = id(cheese_room_temp).state;
      const float airH = id(cheese_room_hum).state;
      const float prbT = id(cheese_probe_temp).state;
      const float sp   = id(setpoint).state;
      const float band = id(alarm_band).state;

      const bool prb_valid = !isnan(prbT);

      const bool too_hot  = prb_valid && (prbT > (sp + band));
      const bool too_cold = prb_valid && (prbT < (sp - band));

      const float far_delta = id(temp_far_delta).state;
      const float mid_delta = id(temp_mid_delta).state;
      const float delta = prb_valid ? (prbT - sp) : 0.0f;

      const char* zone = "NA";
      if (prb_valid) {
        if (delta > far_delta) zone = "FAR";
        else if (delta > mid_delta) zone = "MID";
        else zone = "NEAR";
      }

      const bool r1_on = id(relay_freezer).state;
      const bool r2_on = id(relay_2).state;

      // Air safety thresholds (affichage)
      const float air_cut_on  = sp - id(air_safety_delta).state;
      const float air_cut_off = air_cut_on + id(air_safety_hyst).state;

      char buf[256];
      snprintf(buf, sizeof(buf),
        "Air=%.1fC %.0f%% | Prb=%.2fC | SP=%.2f band=%.2f | d=%.2fC/10m | zone=%s | R1=%d latch=%d (cut=%.1f/%.1f) | hot=%d cold=%d | R2=%d",
        airT, airH,
        prbT, sp, band,
        id(prb_drop_c_per_10m),
        zone,
        r1_on ? 1 : 0, id(air_safety_latched) ? 1 : 0, air_cut_on, air_cut_off,
        too_hot ? 1 : 0, too_cold ? 1 : 0,
        r2_on ? 1 : 0
      );
      return std::string(buf);
